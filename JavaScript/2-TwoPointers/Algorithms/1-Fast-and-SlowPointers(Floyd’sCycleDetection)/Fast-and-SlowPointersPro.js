// --- Two Pointers: Fast and Slow Pointers (Floyd's Cycle Detection) ---

/*
Floyd's Cycle Detection Algorithm (also known as the "tortoise and hare" algorithm)
is a clever way to detect cycles in a sequence of values where each value
determines the next value in the sequence.  This is commonly encountered
in linked lists, but the principle can be applied to other scenarios as well.

Key Idea:
The algorithm uses two pointers: a 'slow' pointer and a 'fast' pointer.
- The slow pointer moves one step at a time.
- The fast pointer moves two steps at a time.

If there is no cycle, the fast pointer will eventually reach the end of the sequence.
If there is a cycle, the fast pointer will eventually catch up to the slow pointer.

Applications in Real-World Projects:

1.  Linked List Cycle Detection:
    * Problem: Determine if a linked list contains a cycle.
    * Real-world use case: Memory management in JavaScript engines.  Detecting
        cyclic references can prevent memory leaks.  The V8 engine, for example,
        uses a variant of this for garbage collection.

2.  Loop Detection in Iterators:
    * Problem: Detect if an iterator has entered an infinite loop.
    * Real-world use case: Preventing infinite loops in data processing pipelines.
        For example, in a complex data transformation in a data warehouse,
        a malformed transformation rule could cause an infinite loop.  This
        algorithm can detect that.

3.  Finding the Start of a Cycle:
    * Problem: Find the starting node of a cycle in a linked list.
    * Real-world use case: Error recovery in data structures.  If a corrupted
        linked list is detected, knowing the start of the cycle can help in
        recovering the data or isolating the corrupted part.

4.  Cryptographic Applications:
     * Problem: Detecting cycles in the state of a pseudo-random number generator.
     * Real-world use case: Assessing the quality of a random number generator.
       A short cycle in a PRNG can lead to vulnerabilities in cryptographic
       applications.  Floyd's algorithm can help detect these weaknesses.

5.  Detecting Duplicate Files:
    * Problem:  Identifying files with identical content in a file system.
    * Real-world use case:  File system optimization.  If you consider the
       file content hash as the "next" element in a sequence, a cycle would
       indicate duplicate content.  This is a very abstract analogy, but the
       core idea of cycle detection is there.

6.  Game Development (State Machine Loops):
    * Problem: Detecting loops in game state transitions.
    * Real-world use case:  Verifying game logic.  In a complex game with many
       states and transitions, a bug could cause the game to enter an infinite
       loop.  This algorithm can help detect such loops during testing.

*/

// --- Helper Function (Simulates a Linked List Node) ---
class ListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
    }
}

// --- 1. Linked List Cycle Detection ---
/*
Problem: Given the head of a linked list, determine if the list has a cycle.
Implementation:
-   Create a sample linked list (with and without a cycle for testing).
-   Use Floyd's algorithm to detect the cycle.
-   Return true if a cycle exists, false otherwise.
*/
function hasCycle(head) {
    if (!head || !head.next) {
        return false; // No cycle if the list is empty or has only one node
    }

    let slow = head;
    let fast = head.next; // Start fast one step ahead

    while (slow && fast && fast.next) {
        if (slow === fast) {
            return true; // Cycle detected
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return false; // No cycle
}

// --- 2. Loop Detection in Iterators (Simulated) ---
/*
Problem:  Detect a loop in a sequence generated by an iterator function.
Implementation:
-   Simulate an iterator that generates a sequence with a potential loop.
-   Use Floyd's algorithm to detect the loop in the generated sequence.
-   Return true if a loop is detected, false otherwise.
*/
function detectLoopInIterator(iterator, maxIterations = 1000) {
  let slow = iterator();
  let fast = iterator();

  if (typeof slow === 'undefined' || typeof fast === 'undefined') {
    return false; // Handle empty iterator case
  }
  let count = 0;
  while (count < maxIterations) { // Add a max iteration to prevent infinite loop in test
    if (slow === null || fast === null) {
      return false;
    }
    slow = iterator(slow); // Pass the previous value to the iterator
    fast = iterator(iterator(fast));
    if (slow === fast) {
      return true;
    }
    count++;
  }
  return false;
}

// --- 3. Finding the Start of a Cycle in a Linked List ---
/*
Problem: Given the head of a linked list with a cycle, find the node where the cycle begins.
Implementation:
-   Use Floyd's algorithm to find the meeting point of the slow and fast pointers.
-   If there is a cycle, move the slow pointer back to the head and move both
    pointers one step at a time until they meet again.  This meeting point is
    the start of the cycle.
-   Return the starting node of the cycle, or null if there is no cycle.
*/
function findCycleStart(head) {
    if (!head || !head.next) {
        return null; // No cycle possible
    }

    let slow = head;
    let fast = head;

    // Phase 1: Detect the cycle
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow === fast) {
            break; // Cycle detected, break the loop
        }
    }

    // If no cycle was detected
    if (slow !== fast) {
        return null;
    }

    // Phase 2: Find the start of the cycle
    slow = head;
    while (slow !== fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow; // Or fast, they meet at the start of the cycle
}

// --- 4. Cryptographic Application (Simulated PRNG Cycle) ---
/*
Problem: Detect a cycle in the output of a pseudo-random number generator (PRNG).
Implementation:
-   Simulate a simple PRNG (for demonstration purposes).  A real-world PRNG
    would be much more complex.
-   Use Floyd's algorithm to detect cycles in the sequence of generated numbers.
-   Return true if a cycle is detected within a reasonable number of iterations.
*/
function detectPRNGCycle(seed, maxIterations = 1000) {
    // Simulate a simple PRNG (not cryptographically secure)
    const prng = (prev) => {
        return (prev * 1664525 + 1013904223) % 0xFFFFFFFF;
    };

    let slow = seed;
    let fast = seed;
    let count = 0;

    while (count < maxIterations) {
        slow = prng(slow);
        fast = prng(prng(fast));
        if (slow === fast) {
            return true; // Cycle detected
        }
        count++;
    }
    return false; // No cycle detected within maxIterations
}

// --- 5. Detecting Duplicate Files (Simulated with Hash Codes) ---
/*
Problem:  Detect duplicate files based on a simplified hash code comparison.
Implementation:
-   Simulate generating hash codes for files.  In a real application, you'd
    use a proper hashing algorithm (e.g., SHA-256).
-   The 'next' function in this analogy is: "given a hash, what's the next
    hash in the sequence of file hashes we are considering".  If two files
    have the same hash, they "point" to the same next hash.
-   Use Floyd's algorithm to detect if there's a cycle in this sequence of hashes.
-   This is a simplification, as true duplicate detection doesn't create a
    literal linked list.  It's more of an analogy to show how cycle detection
    *could* be conceptually applied.
*/
function detectDuplicateFiles(fileHashes) {
    const getNextHashIndex = (index) => {
        // This simulates the "next" pointer.  If a hash repeats, it creates a loop.
        for (let i = index + 1; i < fileHashes.length; i++) {
            if (fileHashes[i] === fileHashes[index]) {
                return i; // Index of the next occurrence of the same hash
            }
        }
        return -1; // No duplicate found after this index
    };

    if (!fileHashes || fileHashes.length <= 1) {
        return false; // No duplicates possible with 0 or 1 files
    }

    let slow = 0;
    let fast = 0;
    let count = 0;
    const maxIterations = fileHashes.length * 2; // Avoid infinite loop

    while (count < maxIterations) {
        slow = getNextHashIndex(slow);
        fast = getNextHashIndex(fast);
        if (fast !== -1) {
           fast = getNextHashIndex(fast);
        }

        if (slow === -1 || fast === -1) {
            return false; // No cycle (no duplicates that form a loop)
        }

        if (slow === fast) {
            return true; // Cycle detected (duplicate hashes causing a loop)
        }
        count++;
    }
    return false; // No cycle within max iterations
}

// --- 6. Game Development (State Machine Loops) ---
/*
Problem: Detect loops in a game's state transition logic.
Implementation:
-   Simulate a simplified game state machine with transitions.
-   Use Floyd's algorithm to detect if the game enters a loop.
-   Return true if a loop is detected, false otherwise.
*/
function detectGameStateLoop(initialState, transitions, maxSteps = 100) {
    let slow = initialState;
    let fast = initialState;
    let steps = 0;

    const getNextState = (state) => {
        if (transitions[state]) {
            return transitions[state];
        }
        return null; // No transition defined for this state
    };

    while (steps < maxSteps) {
        slow = getNextState(slow);
        fast = getNextState(getNextState(fast)); // Apply transition twice for fast

        if (slow === null || fast === null) {
            return false; // Reached a dead end, no loop
        }

        if (slow === fast) {
            return true; // Loop detected
        }
        steps++;
    }
    return false; // No loop detected within maxSteps
}

// --- Test Cases ---
function runTests() {
    console.log("--- Two Pointers (Fast and Slow Pointers) Tests ---");

    // 1. Linked List Cycle Detection
    console.log("\n1. Linked List Cycle Detection:");
    let head1 = new ListNode(1);
    head1.next = new ListNode(2);
    head1.next.next = new ListNode(3);
    head1.next.next.next = new ListNode(4);
    head1.next.next.next.next = head1.next; // Create a cycle: 4 -> 2
    console.log("  List with cycle:", hasCycle(head1)); // Output: true

    let head2 = new ListNode(1);
    head2.next = new ListNode(2);
    head2.next.next = new ListNode(3);
    console.log("  List without cycle:", hasCycle(head2)); // Output: false

    // 2. Loop Detection in Iterators
    console.log("\n2. Loop Detection in Iterators:");
    let count = 0;
    const iterator1 = () => {
        count++;
        if (count <= 5) return count;
        if (count > 5 && count <= 10) return 3; // Create a loop: 6th call returns to 3rd
        return null; // End of iteration
    };
    console.log("  Iterator with loop:", detectLoopInIterator(iterator1)); // Output: true

    count = 0; //reset
    const iterator2 = () => {
        count++;
        if (count <= 5) return count;
        return null;
    };
    console.log("  Iterator without loop:", detectLoopInIterator(iterator2)); // Output: false

    // 3. Finding the Start of a Cycle in a Linked List
    console.log("\n3. Finding the Start of a Cycle in a Linked List:");
    let head3 = new ListNode(1);
    head3.next = new ListNode(2);
    head3.next.next = new ListNode(3);
    head3.next.next.next = new ListNode(4);
    head3.next.next.next.next = head3.next; // Create a cycle: 4 -> 2
    let cycleStart = findCycleStart(head3);
    console.log("  Start of cycle (should be 2):", cycleStart ? cycleStart.val : "No cycle"); // Output: 2

    let head4 = new ListNode(1);
    head4.next = new ListNode(2);
    head4.next.next = new ListNode(3);
    console.log("  Start of no cycle:", findCycleStart(head4));  //Output: null

    // 4. Cryptographic Application (Simulated PRNG Cycle)
    console.log("\n4. Cryptographic Application (Simulated PRNG Cycle):");
    let seed = 12345;
    console.log("  PRNG with cycle:", detectPRNGCycle(seed)); // Output: true or false (depends on the PRNG) -  This PRNG will have a cycle.
    console.log("  PRNG without cycle (within 100 iterations):", detectPRNGCycle(67890)); //Output: false within 100

    // 5. Detecting Duplicate Files (Simulated with Hash Codes)
    console.log("\n5. Detecting Duplicate Files (Simulated with Hash Codes):");
    let fileHashes1 = [123, 456, 789, 456, 101, 456]; // Duplicate: 456
    console.log("  Duplicate files detected:", detectDuplicateFiles(fileHashes1)); // Output: true

    let fileHashes2 = [123, 456, 789, 101, 202]; // No duplicates
    console.log("  No duplicate files:", detectDuplicateFiles(fileHashes2)); // Output: false
    let fileHashes3 = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
    console.log("  Long fileHashes:", detectDuplicateFiles(fileHashes3));

    // 6. Game Development (State Machine Loops)
    console.log("\n6. Game Development (State Machine Loops):");
    let initialState = 'A';
    let transitions1 = {
        'A': 'B',
        'B': 'C',
        'C': 'D',
        'D': 'B' // Loop: D -> B -> C -> D
    };
    console.log("  Game state loop detected:", detectGameStateLoop(initialState, transitions1)); // Output: true

    let transitions2 = {
        'A': 'B',
        'B': 'C',
        'C': 'D',
        'D': 'E' // No loop
    };
    console.log("  No game state loop:", detectGameStateLoop(initialState, transitions2)); // Output: false
    let transitions3 = {
        'A': 'B',
        'B': 'C',
        'C': 'D',
        'D': 'E',
        'E': 'F',
        'F': 'G',
        'G': 'H',
        'H': 'I',
        'I': 'J',
        'J': 'K',
        'K': 'L',
        'L': 'M',
        'M': 'N',
        'N': 'O',
        'O': 'P',
        'P': 'Q',
        'Q': 'R',
        'R': 'S',
        'S': 'T',
        'T': 'U',
        'U': 'V',
        'V': 'W',
        'W': 'X',
        'X': 'Y',
        'Y': 'Z',
        'Z': 'A', // Loop back to start
    };
    console.log("  Long state machine loop:", detectGameStateLoop(initialState, transitions3));
}

runTests();
